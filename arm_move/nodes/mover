
#!/usr/bin/env python

from __future__ import print_function
from six.moves import input

import sys
import copy
import rospy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from arm_move.srv import Step, Reset
from std_srvs.srv import Empty, EmptyResponse






try:
    from math import pi, tau, dist, fabs, cos
except:  # For Python 2 compatibility
    from math import pi, fabs, cos, sqrt

    tau = 2.0 * pi

    def dist(p, q):
        return sqrt(sum((p_i - q_i) ** 2.0 for p_i, q_i in zip(p, q)))



from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list


class Move:
    def __init__(self):
        
        moveit_commander.roscpp_initialize(sys.argv)
        rospy.init_node("mover", anonymous=True)
        self.waypoints = rospy.get_param("/waypoints")
        self.reset = rospy.Service('reset', Reset, self.reset_fn)
        self.step = rospy.Service('step', Step, self.step_fn)
        self.follow = rospy.Service('follow', Empty, self.follow_fn)
        



        self.robot = moveit_commander.RobotCommander()

        self.scene = moveit_commander.PlanningSceneInterface()
        

        #display_trajectory_publisher = rospy.Publisher("/move_group/display_planned_path", moveit_msgs.msg.DisplayTrajectory,queue_size=20,)

        self.move_group = moveit_commander.MoveGroupCommander("interbotix_arm")

        self.move_group_2 = moveit_commander.MoveGroupCommander("interbotix_gripper")


        


        self.box_name = ""
        self.box_name2 = ""
        self.box_name3 = ""
        
       

    def wait_for_state_update(self, box_is_known=False, box_is_attached=False, timeout=4):
        
        box_name = self.box_name
        scene = self.scene

        
        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name in scene.get_known_object_names()

            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False
        ## END_SUB_TUTORIAL

    def add_box(self, timeout=4):
        rospy.sleep(3)
        
        box_name = self.box_name
        scene = self.scene

        
        self.box_pose = geometry_msgs.msg.PoseStamped()
        self.box_pose.header.frame_id = "world"
        self.box_pose.pose.orientation.w = 1.0
        self.box_pose.pose.position.x = 0
        self.box_pose.pose.position.y = 0
        self.box_pose.pose.position.z = 0 
        box_name = "box"
        
        self.box_name = box_name
        while not self.wait_for_state_update(box_is_known=True):
            scene.add_box(box_name,self.box_pose, size=(1.2, 1.2, 0))

    '''
    
    def wait_for_state_update2(self, box_is_known=False, box_is_attached=False, timeout=4):
        
        box_name2 = self.box_name2
        scene = self.scene

        
        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name2])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name2 in scene.get_known_object_names()

            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False

    
    def add_box2(self, timeout=4):
        rospy.sleep(3)
        
        box_name2 = self.box_name2
        scene = self.scene

        
        self.box_pose2 = geometry_msgs.msg.PoseStamped()
        self.box_pose2.header.frame_id = "world"
        self.box_pose2.pose.orientation.w = 1.0
        self.box_pose2.pose.position.x = 0
        self.box_pose2.pose.position.y = 0.2
        self.box_pose2.pose.position.z = 0.01905 
        box_name3 = "box_2"
        
        self.box_name2 = box_name2
        while not self.wait_for_state_update2(box_is_known=True):
            scene.add_box(box_name2,self.box_pose2, size=(0.024, 0.0381, 0.0381))
            
    
        '''
     



    def wait_for_state_update3(self, box_is_known=False, box_is_attached=False, timeout=4):
        
        box_name3 = self.box_name3
        scene = self.scene

        
        start = rospy.get_time()
        seconds = rospy.get_time()
        while (seconds - start < timeout) and not rospy.is_shutdown():
            # Test if the box is in attached objects
            attached_objects = scene.get_attached_objects([box_name3])
            is_attached = len(attached_objects.keys()) > 0

            # Test if the box is in the scene.
            # Note that attaching the box will remove it from known_objects
            is_known = box_name3 in scene.get_known_object_names()

            # Test if we are in the expected state
            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            # Sleep so that we give other threads time on the processor
            rospy.sleep(0.1)
            seconds = rospy.get_time()

        # If we exited the while loop without returning then we timed out
        return False

    
    def add_box3(self, timeout=4):
        rospy.sleep(3)
        
        box_name3 = self.box_name3
        scene = self.scene

        
        self.box_pose3 = geometry_msgs.msg.PoseStamped()
        self.box_pose3.header.frame_id = "world"
        self.box_pose3.pose.orientation.w = 1.0
        self.box_pose3.pose.position.x = 0.15
        self.box_pose3.pose.position.y = 0.2
        self.box_pose3.pose.position.z = 0.025
        box_name3 = "box_3"
        
        self.box_name3 = box_name3
        while not self.wait_for_state_update3(box_is_known=True):
            scene.add_box(box_name3,self.box_pose3, size=(0.14, 0.09, 0.05))


    
            





    def reset_fn(self, req):
        rospy.loginfo("reset is working")
        set_empty_list = req.data
        self.move_group.set_named_target("Home")
        self.move_group.go()
    
        if set_empty_list == True:
            self.waypoints = []
            rospy.set_param("/waypoints", self.waypoints)
        return 0


    def step_fn(self, req):
        #Take user input
        rospy.loginfo("step is working")
        pose_goal = geometry_msgs.msg.Pose()

        
        pose_goal.position.x = req.x
        pose_goal.position.y = req.y
        pose_goal.position.z = req.z
        pose_goal.orientation.x = req.x1
        pose_goal.orientation.y = req.y1
        pose_goal.orientation.z = req.z1
        pose_goal.orientation.w = req.w
        set_gripper = req.a
        waypoints_list = [
            pose_goal.position.x, 
            pose_goal.position.y,
            pose_goal.position.z,
            pose_goal.orientation.x,
            pose_goal.orientation.y,
            pose_goal.orientation.z,
            pose_goal.orientation.w,
            set_gripper
        ]
        self.move_group.set_pose_target(pose_goal, self.move_group.get_end_effector_link())
        (a, b, c, error_code) = self.move_group.plan()

        if error_code.val == 1:
            
            self.move_group.go(pose_goal)
            self.waypoints.append(waypoints_list)
            if set_gripper == False:
                self.move_group_2.set_named_target("Open")
                self.move_group_2.go()
            else:
                self.move_group_2.set_named_target("Closed")
                self.move_group_2.go()
            rospy.set_param('/waypoints', self.waypoints)
        else:
            self.move_group.stop()

        return error_code.val
        
    
    def follow_fn(self, req):
        
        for i in self.waypoints:
            rospy.logerr(i)
            pose_goal = geometry_msgs.msg.Pose()
            pose_goal.position.x = i[0]
            pose_goal.position.y = i[1]
            pose_goal.position.z = i[2]
            pose_goal.orientation.x = i[3]
            pose_goal.orientation.y = i[4]
            pose_goal.orientation.z = i[5]
            pose_goal.orientation.w = i[6]
            set_gripper = i[7]
            self.move_group.go(pose_goal)
            if set_gripper == False:
                self.move_group_2.set_named_target("Open")
                self.move_group_2.go()
            else:
                self.move_group_2.set_named_target("Closed")
                self.move_group_2.go()
        
        return EmptyResponse()
        
    


    
    
    
    
def main():
    n = Move()
    n.add_box()
    #n.add_box2()
    n.add_box3()
    rospy.spin()
    


            




if __name__ == "__main__":
    try:
       
        main()
    except rospy.ROSInterruptException:
        pass
